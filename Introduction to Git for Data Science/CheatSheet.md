>A version control system is a tool that manages changes made to the files and directories in a project. Nothing that is saved to Git is ever lost, so you can always go back to see which results were generated by which versions of your programs.

>Git automatically notifies you when your work conflicts with someone else's, so it's harder (but not impossible) to accidentally overwrite work.

>Git can synchronize work done by different people on different machines, so it scales as your team does.

>Each of your Git projects has two parts: the files and directories that you create and edit directly, and the extra information that Git records about the project's history. The combination of these two things is called a repository.

## How can I check the state of a repository?

>When you are using Git, you will frequently want to check the status of your repository. To do this, run the command **git status**, which displays a list of the files that have been modified since the last time changes were saved.

## How can I tell what I have changed?

>Git has a staging area in which it stores files with changes you want to save that haven't been saved yet. Putting files in the staging area is like putting things in a box, while committing those changes is like putting that box in the mail: you can add more things to the box or take things out as often as you want, but once you put it in the mail, you can't make further changes.

Working Directory---------> Staging Area---------> Permanent Storage(.git repository)

>git status shows you which files are in this *staging area*, and which files have changes that *haven't yet been put there*. In order to compare the file as it currently is to what you last saved, you can use **git diff filename**. **git diff** without any filenames will show you all the changes in your repository, while git diff directory will show you the changes to the files in some directory.

## What is in a diff?

A diff is a formatted display of the differences between two sets of files. Git displays diffs like this:
```
diff --git a/report.txt b/report.txt
index e713b17..4c0742a 100644
--- a/report.txt
+++ b/report.txt
@@ -1,4 +1,4 @@
-# Seasonal Dental Surgeries 2017-18
+# Seasonal Dental Surgeries (2017) 2017-18

 TODO: write executive summary.
```
In it, a and b are placeholders meaning "the first version" and "the second version".
An index line showing keys into Git's internal database of changes. We will explore these in the next chapter.
--- a/report.txt and +++ b/report.txt, which indicate that lines being removed are prefixed with -, while lines being added are prefixed with +.
A line starting with @@ that tells where the changes are being made. The pairs of numbers are start line,number of lines changed. Here, the diff output shows that 4 lines from line 1 are being removed and replaced with new lines.
A line-by-line listing of the changes with - showing deletions and + showing additions. (We have also configured Git to show deletions in red and additions in green.) Lines that haven't changed are sometimes shown before and after the ones that have in order to give context; when they appear, they don't have either + or - in front of them.

## What's the first step in saving changes?

>You commit changes to a Git repository in two steps:

1. Add one or more files to the staging area.
2. Commit everything in the staging area.
To add a file to the staging area, use **git add filename**

## How can I tell what's going to be committed?

To compare the state of your files with those in the staging area, you can use **git diff -r HEAD**. The -r flag means "compare to a particular revision", and HEAD is a shortcut meaning "the most recent commit".

You can restrict the results to a single file or directory using **git diff -r HEAD path/to/file**

## Interlude: how can I edit a file?
Unix has a bewildering variety of text editors. In this course, we will sometimes use a very simple one called Nano. If you type **nano filename**, it will open filename for editing (or create it if it doesn't already exist). You can then move around with the arrow keys, delete characters with the backspace key, and so on. You can also do a few other operations with control-key combinations:

Ctrl-K: delete a line.
Ctrl-U: un-delete a line.
Ctrl-O: save the file ('O' stands for 'output').
Ctrl-X: exit the editor.

## How do I commit changes?

>git commit -m "Program appears to have become self-aware."

If you accidentally mistype a commit message, you can change it using the --amend flag.

>git commit --amend - m "new message"

## How can I view a repository's history?

> git log
```
commit 0430705487381195993bac9c21512ccfb511056d
Author: Rep Loop <repl@datacamp.com>
Date:   Wed Sep 20 13:42:26 2017 +0000

    Added year to report title.
```

The commit line displays a unique ID for the commit called a hash;

**When you run git log, Git automatically uses a pager to show one screen of output at a time. Press the space bar to go down a page or the 'q' key to quit.**

## How can I view a specific file's history?

> git log path

## How do I write a better log message?

Writing a one-line log message with git commit -m "message"is good enough for very small changes, but your collaborators (including your future self) will appreciate more information.

> got commit 

Use Ctrl+O and Ctrl+X to save and leave the editor.

## How does Git store information?

You may wonder what information is stored by each commit that you make. Git uses a three-level structure for this.

1. A commit contains metadata such as the author, the commit message, and the time the commit happened. In the diagram below, the most recent commit is at the bottom (feed0098), and vertical arrows point up towards the previous ("parent") commits.
2. Each commit also has a tree, which tracks the names and locations in the repository when that commit happened. In the oldest (top) commit, there were two files tracked by the repository.
3. For each of the files listed in the tree, there is a blob. This contains a compressed snapshot of the contents of the file when the commit happened. (Blob is short for binary large object, which is a SQL database term for "may contain data of any kind".) In the middle commit, report.md and draft.md were changed, so the blobs are shown next to that commit. data/northern.csv didn't change in that commit, so the tree links to the blob from the previous commit. Reusing blobs between commits help make common operations fast and minimizes storage space.


![Commit tree](commit-tree-blob.png)

## What is a hash?
Every commit to a repository has a unique identifier called a hash (since it is generated by running the changes through a pseudo-random number generator called a hash function). This hash is normally written as a 40-character hexadecimal string like 7c35a3ce607a14953f070f0f83b5d74c2296ef93, but most of the time, you only have to give Git the first 6 or 8 characters in order to identify the commit you mean.

Hashes are what enable Git to share data efficiently between repositories. If two files are the same, their hashes are guaranteed to be the same. Similarly, if two commits contain the same files and have the same ancestors, their hashes will be the same as well. Git can therefore tell what information needs to be saved where by comparing hashes rather than comparing entire files.

## How can I view a specific commit?

To view the details of a specific commit, you use the command **git show** with the first few characters of the commit's hash. 
The first part is the same as the log entry shown by git log. The second part shows the changes; as with git diff.

## What is Git's equivalent of a relative path?

>A hash is like an absolute path: it identifies a specific commit. Another way to identify a commit is to use the equivalent of a relative path. The special label HEAD, which we saw in the previous chapter, always refers to the most recent commit. The label HEAD~1 then refers to the commit before it, while HEAD~2 refers to the commit before that,and so on.

## How can I see who changed what in a file?

>git annotate file

git log displays the overall history of a project or file, but Git can give even more information: the command git annotate file shows who made the last change to each line of a file and when. 

## How can I see what changed between two commits?

>git show with a commit ID shows the changes made in a particular commit. To see the changes between two commits, you can use **git diff ID1..ID2**, where ID1 and ID2 identify the two commits you're interested in, and the connector .. is a pair of dots. For example, git diff abc123..def456 shows the differences between the commits abc123 and def456, while git diff HEAD~1..HEAD~3 shows the differences between the state of the repository one commit in the past and its state three commits in the past.

## How do I add new files?

>Git does not track files by default. Instead, it waits until you have used git add at least once before it starts paying attention to a file.

## How do I tell Git to ignore certain files?

Data analysis often produces temporary or intermediate files that you don't want to save.
You can tell it to stop paying attention to files you don't care about by creating a file in the root directory of your repository called .gitignore and storing a list of wildcard patterns that specify the files you don't want Git to pay attention to
> build(ignore all files and folders with this name)
> *.mpl 

## How can I remove unwanted files?
>Git can help you clean up files that you have told it you don't want. The command git clean -n will show you a list of files that are in the repository, but whose history Git is not currently tracking. A similar command git clean -f will then delete those files.

>Use this command carefully: **git clean** only works on **untracked files**, so by definition, their history has not been saved. If you delete them with git clean -f, they're gone for good.

## How can I see how Git is configured?

Like most complex pieces of software, Git allows you to change its default settings. To see what the settings are, you can use the command git config --list with one of three additional options:

1. --system: settings for every user on this computer.
2. --global: settings for every one of your projects.
3. --local: settings for one specific project.

Each level overrides the one above it, so local settings (per-project) take precedence over global settings (per-user), which in turn take precedence over system settings (for all users on the computer).

## How can I change my Git configuration?

However, there are two you should set on every computer you use: your name and your email address. These are recorded in the log every time you commit a change, and are often used to identify the authors of a project's content in order to give credit (or assign blame, depending on the circumstances).

>git config --global setting.name setting.value

## How can I commit changes selectively?

You don't have to put all of the changes you have made recently into the staging area at once. For example, suppose you are adding a feature to analysis.R and spot a bug in cleanup.R. After you have fixed it, you want to save your work. Since the changes to cleanup.R aren't directly related to the work you're doing in analysis.R, you should save your work in two separate commits.

The syntax for staging a single file is **git add path/to/file**.

If you make a mistake and accidentally stage a file you shouldn't have, you can unstage the additions with **git reset HEAD** and try again.

## How do I re-stage files?

People often save their work every few minutes when they're using a desktop text editor. Similarly, it's common to use git add periodically to save the most recent changes to a file to the staging area. This is particularly useful when the changes are experimental and you might want to undo them without cluttering up the repository's history.

## How can I undo changes to unstaged files?

>git checkout -- filename

will discard the changes **that have not yet been staged**. (The double dash -- must be there to separate the git checkout command from the names of the file or files you want to recover.)

## How can I undo changes to staged files?

At the start of this chapter you saw that git reset will unstage files that you previously staged using git add. By combining git reset with git checkout, you can undo changes to a file that you staged changes to. The syntax is as follows.
```
git reset HEAD path/to/file
git checkout -- path/to/file
```

## How do I restore an old version of a file?

You previously saw how to use git checkout to undo the change that you made since the last commit. This command can also be used to go back even further into a file's history and restore versions of that file from a commit. In this way, you can think of committing as saving your work, and checking out as loading that saved version

> git checkout 2242bd report.txt

Restoring a file doesn't erase any of the repository's history. Instead, the act of restoring the file is saved as another commit, because you might later want to undo your undoing.

>One more thing: there's another feature of git log that will come in handy here. Passing - then a number restricts the output to that many commits. For example, **git log -3 report.txt** shows you the last three commits involving report.txt.

## How can I undo all of the changes I have made?

So far, you have seen how to undo changes to a single file at a time using **git reset HEAD path/to/file**

One way to do this is to give git reset a directory. For example, git reset HEAD data will unstage any files from the data directory. Even better, if you don't provide any files or directories, it will unstage everything. Even even better, HEAD is the default commit to unstage, so you can simply write git reset to unstage everything.

Similarly git checkout -- data will then restore the files in the data directory to their previous state. You can't leave the file argument completely blank, but recall from Introduction to Shell for Data Science that you can refer to the current directory as .. So git checkout -- . will revert all files in the current directory.

# What is a branch?

One of the reasons Git is popular is its support for creating branches, which allows you to have multiple versions of your work, and lets you track each version systematically.

Each branch is like a parallel universe: changes you make in one branch do not affect other branches (until you merge them back together).

The three-part data structure Git uses to record a repository's history: blobs for files, trees for the saved states of the repositories, and commits to record the changes. Branches are the reason Git needs both trees and commits: a commit will have two parents when branches are being merged.

## How can I see what branches my repository has?

>git branch 

To list all of the branches in a repository, you can run the command git branch. The branch you are currently in will be shown with a * **beside its name**.

## How can I view the differences between branches?

> git diff branch-1..branch-2

## How can I switch from one branch to another?

You previously used git checkout with a commit hash to switch the repository state to that hash. You can also use **git checkout with the name of a branch** to switch to that branch.

>When you run git branch, it puts a * beside the name of the branch you are currently in.

>Git will only let you do this if all of your changes have been committed. You can get around this, but it is outside the scope of this course.

**git rm**. This removes the file (just like the shell command rm) then stages the removal of that file with git add, all in one step.

## How can I create a branch?

> git checkout -b "branch-name"

## How can I merge two branches?

>Branching lets you create parallel universes; merging is how you bring them back together. When you merge one branch (call it the source) into another (call it the destination), Git incorporates the changes made to the source branch into the destination branch. If those changes don't overlap, the result is a new commit in the destination branch that includes everything from the source branch. 

> git merge summary-statistics master

## What are conflicts?

Sometimes the changes in two branches will conflict with each other: for example, bug fixes might touch the same lines of code, or analyses in two different branches may both append new (and different) records to a summary data file. In this case, Git relies on you to reconcile the conflicting changes.
> Git can merge the deletion of line automatically.
> Git can merge the addition of line automatically.
> Conflicts if same line changes

## How can I merge two branches with conflicts?

In many cases, the destination branch name will be HEAD, because you will be merging into the current branch.

When there is a conflict during a merge, Git tells you that there's a problem, and running git status after the merge reminds you which files have conflicts that you need to resolve by printing both modified: beside the files' names.

Inside the file, Git leaves markers that look like this to tell you where the conflicts occurred:

```
<<<<<<< destination-branch-name
...changes from the destination branch...
=======
...changes from the source branch...
>>>>>>> source-branch-name
```

## How can I create a brand new repository?

> git init project-name

## How can I turn an existing project into a Git repository?

> git init
> git init /path/to/project

## How can I create a copy of an existing repository?

Sometimes you will join a project that is already running, inherit a project from someone else, or continue working on one of your own projects on a new machine. In each case, you will clone an existing repository instead of creating a new one. Cloning a repository does exactly what the name suggests: it creates a copy of an existing repository (including all of its history) in a new directory.
 
> git clone URL

> git clone /home/path/repo1 /home/path2/repo2

## How can I find out where a cloned repository originated?

When you clone a repository, Git remembers where the original repository was. It does this by storing a remote in the new repository's configuration. A remote is like a browser bookmark with a name and a URL.

> git remote

If you are in a repository, you can list the names of its remotes using git remote.

If you want more information, you can use **git remote -v** (for "verbose"), which shows the remote's URLs. Note that "URLs" is plural: it's possible for a remote to have several URLs associated with it for different purposes, though in practice each remote is almost always paired with just one URL.

## How can I define remotes?

When you clone a repository, Git automatically creates a remote called origin that points to the original repository. You can add more remotes using:

> git remote add remote-name URL

and remove existing ones using:

>git remote rm remote-name
You can connect any two Git repositories this way, but in practice, you will almost always connect repositories that share some common ancestry.

## How can I pull in changes from a remote repository?

Pulling changes is straightforward: the command git pull remote branch gets everything in branch in the remote repository identified by remote and merges it into the current branch of your local repository. 

## What happens if I try to pull when I have unsaved changes?

> Just as Git stops you from switching branches when you have unsaved work, it also stops you from pulling in changes from a remote repository when doing so might overwrite things you have done locally. The fix is simple: either commit your local changes or revert them,and then try to pull again.

## How can I push my changes to a remote repository?

> git push remote-name branch-name

## What happens if my push conflicts with someone else's work?

Overwriting your own work by accident is bad; overwriting someone else's is worse.

To prevent this happening, Git does not allow you to push changes to a remote repository unless you have merged the contents of the remote repository into your own work.